<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rangeless::fn: rangeless::fn</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rangeless::fn
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespacerangeless_1_1fn.html" title="LINQ -like library of higher-order functions for data manipulation.">rangeless::fn</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><code>range</code>-free LINQ-like library of higher-order functions for manipulation of containers and lazy input-sequences.</h2>
<ul>
<li>Reduce the amount of mutable state.</li>
<li>Flatten control-flow.</li>
<li>Lessen the need to deal with iterators directly.</li>
<li>Make the code more expressive and composeable.</li>
</ul>
<p>This library is intended for moderate to advanced-level c++ programmers that like the idea of c++ <code>ranges</code>, but can't or choose not to use them for various reasons (e.g. high complexity, compilation overhead, debug-build performance, size of the library, etc).</p>
<p>Motivations:</p><ul>
<li><a href="https://www.fluentcpp.com/2019/09/13/the-surprising-limitations-of-c-ranges-beyond-trivial-use-cases/">https://www.fluentcpp.com/2019/09/13/the-surprising-limitations-of-c-ranges-beyond-trivial-use-cases/</a></li>
<li><a href="https://brevzin.github.io/c++/2020/07/06/split-view/">https://brevzin.github.io/c++/2020/07/06/split-view/</a></li>
<li><a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/">https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/</a></li>
</ul>
<p>### Simple examples </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacerangeless_1_1fn.html">fn</a> = <a class="code" href="namespacerangeless_1_1fn.html">rangeless::fn</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#define LAMBDA(expr) ([&amp;](const auto&amp; _ ){ return expr; })</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>employee_t</div><div class="line">{</div><div class="line">    std::string last_name;</div><div class="line">    std::string first_name;</div><div class="line">            <span class="keywordtype">int</span> years_onboard;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> employees = std::vector&lt;employee_t&gt;{<span class="comment">/*...*/</span>};</div><div class="line"></div><div class="line">employees = <a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">fn::where</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( _.last_name != <span class="stringliteral">&quot;Doe&quot;</span> )( std::move(employees));</div><div class="line">employees = <a class="code" href="group__ordering.html#ga30d5a61dda81290e8775bec161982312">fn::take_top_n_by</a>(10, <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( _.years_onboard ))( std::move(employees));</div><div class="line">employees = <a class="code" href="group__ordering.html#gacdb4c259d22527440d63b856cf4b7292">fn::sort_by</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( std::tie( _.last_name, _.first_name) )( std::move(employees));</div><div class="line"></div><div class="line"><span class="comment">// or, as function-composition:</span></div><div class="line"></div><div class="line">employees = <a class="code" href="group__ordering.html#gacdb4c259d22527440d63b856cf4b7292">fn::sort_by</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( std::tie( _.last_name, _.first_name))(</div><div class="line">                <a class="code" href="group__ordering.html#ga30d5a61dda81290e8775bec161982312">fn::take_top_n_by</a>(10, <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( _.years_onboard ))(</div><div class="line">                    <a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">fn::where</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( _.last_name != <span class="stringliteral">&quot;Doe&quot;</span> )(</div><div class="line">                        std::move(employees) )));</div></div><!-- fragment --><p>How does this work? E.g. <code>fn::sort_by(projection_fn)</code> is a higher-order function that returns an overloaded unary function that takes inputs by value (normally passed as rvalue), sorts them by the user-provided projection, and returns them by value.</p>
<p><code>operator %</code> is syntax-sugar, similar to F#'s operator <code>|&gt;</code>, that enables structuring your code in top-down manner, consistent with the direction of the data-flow. It is implemented as: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Arg, <span class="keyword">typename</span> F&gt;</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacerangeless_1_1fn_1_1operators.html#ad5e5157fefeff01ec25d231f7f1f73a5">operator % </a>(Arg&amp;&amp; arg, F&amp;&amp; <a class="code" href="namespacerangeless_1_1fn.html">fn</a>) -&gt; decltype( std::forward&lt;F&gt;(<a class="code" href="namespacerangeless_1_1fn.html">fn</a>)( std::forward&lt;Arg&gt;(arg)) )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::forward&lt;F&gt;(<a class="code" href="namespacerangeless_1_1fn.html">fn</a>)( std::forward&lt;Arg&gt;(arg));</div><div class="line">}</div></div><!-- fragment --><p>The original example can then be written as: </p><div class="fragment"><div class="line"><span class="keyword">using</span> fn::operators::operator%;   <span class="comment">// arg % f % g % h; // h( g( f( std::forward&lt;Arg&gt;(arg))));</span></div><div class="line"><span class="keyword">using</span> fn::operators::operator%=;  <span class="comment">// arg %= fn;       // arg = fn( std::move(arg));</span></div><div class="line"></div><div class="line">employees %= <a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">fn::where</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( _.last_name != <span class="stringliteral">&quot;Doe&quot;</span> );</div><div class="line">employees %= <a class="code" href="group__ordering.html#ga30d5a61dda81290e8775bec161982312">fn::take_top_n_by</a>(10, <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( _.years_onboard ));</div><div class="line">employees %= <a class="code" href="group__ordering.html#gacdb4c259d22527440d63b856cf4b7292">fn::sort_by</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( std::tie( _.last_name, _.first_name) );</div><div class="line"></div><div class="line"><span class="comment">// or:</span></div><div class="line"></div><div class="line">employees = std::move(employees)</div><div class="line">          % <a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">fn::where</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( _.last_name != <span class="stringliteral">&quot;Doe&quot;</span> )</div><div class="line">          % <a class="code" href="group__ordering.html#ga30d5a61dda81290e8775bec161982312">fn::take_top_n_by</a>(10, <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( _.years_onboard ))</div><div class="line">          % <a class="code" href="group__ordering.html#gacdb4c259d22527440d63b856cf4b7292">fn::sort_by</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( std::tie( _.last_name, _.first_name) );</div></div><!-- fragment --><p>Note on the <code>LAMBDA</code> macro: a common complaint among c++ programmers is the verbosity of lambdas, which are used a lot with this library. The macro can to alleviate it somewhat. I'm personally ambivalent to it; it's not defined in the library.</p>
<p>### Example: Top-5 most frequent words chosen among the words of the same length. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> my_isalnum = [](<span class="keyword">const</span> <span class="keywordtype">int</span> ch)</div><div class="line">{    </div><div class="line">    <span class="keywordflow">return</span> std::isalnum(ch) || ch == <span class="charliteral">&#39;_&#39;</span>; </div><div class="line">};   </div><div class="line"></div><div class="line"><span class="keyword">using</span> counts_t = std::map&lt;std::string, size_t&gt;;</div><div class="line"></div><div class="line"><a class="code" href="group__view.html#ga9243f1562b82e61f7554101d304a41de">fn::from</a>(</div><div class="line">    std::istreambuf_iterator&lt;char&gt;(istr.rdbuf()),</div><div class="line">    std::istreambuf_iterator&lt;char&gt;{})</div><div class="line">    </div><div class="line">  % <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( (<span class="charliteral">&#39;A&#39;</span> &lt;= _ &amp;&amp; _ &lt;= <span class="charliteral">&#39;Z&#39;</span>) ? char(_ - (<span class="charliteral">&#39;Z&#39;</span> - <span class="charliteral">&#39;z&#39;</span>)) : _ ) <span class="comment">// to-lower</span></div><div class="line">  % <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::<a class="code" href="group__grouping.html#ga95a5c85e062778a92a1d3e689109d6c9">group_adjacent_by</a>(my_isalnum)             <span class="comment">// returns sequence-of-std::string</span></div><div class="line">  % <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::<a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">where</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( my_isalnum(_.front()))      <span class="comment">// discard punctuation</span></div><div class="line">  % <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::<a class="code" href="group__to__vec.html#ga7a6c6551c510a7904298887a507bb35b">counts</a>()                                  <span class="comment">// returns map:word-&gt;count</span></div><div class="line">  % <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::<a class="code" href="namespaceexample_1_1my.html#ac421e20b6c1e77123dc2d570e64c63ad">group_all_by</a> <a class="code" href="aln__filter_8cpp.html#a57cabb8d6dc2bad330754354503ad737">LAMBDA</a>( _.first.size())      <span class="comment">// returns [[(word, count)]], each subvector containing words of same length</span></div><div class="line">  % <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::<a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">transform</a>(                                <span class="comment">// transform each sub-vector...</span></div><div class="line">        <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::<a class="code" href="group__ordering.html#ga30d5a61dda81290e8775bec161982312">take_top_n_by</a>(5UL, <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::by::second{})) <span class="comment">// by filtering it taking top-5 by count.</span></div><div class="line">  % <a class="code" href="group__concat.html#gac6a26ae2179802d847910eaa00daac7f">fn::concat</a>()                                  <span class="comment">// undo group_all_by (flatten)</span></div><div class="line">  % <a class="code" href="group__folding.html#ga8568617f52b0e084f2c1303d71705b69">fn::for_each</a>([](<span class="keyword">const</span> counts_t::value_type&amp; kv)</div><div class="line">    {    </div><div class="line">        std::cout &lt;&lt; kv.first &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; kv.second &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    })   </div><div class="line">  ; </div><div class="line"></div><div class="line"><span class="comment">// compilation time:</span></div><div class="line"><span class="comment">// &gt;&gt;time g++ -I ../include/ -std=c++14 -o test.o -c test.cpp</span></div><div class="line"><span class="comment">// real   0m1.176s</span></div><div class="line"><span class="comment">// user   0m1.051s</span></div><div class="line"><span class="comment">// sys    0m0.097s</span></div></div><!-- fragment --><p>See <a href="https://godbolt.org/z/f6eptu">A rudimentary lazy TSV parser</a>.</p>
<p>See <a href="calendar_8cpp_source.html">calendar.cpp</a> vs. <a href="https://github.com/BartoszMilewski/Calendar/blob/master/Main.hs">Haskell</a> vs. <a href="https://github.com/ericniebler/range-v3/blob/master/example/calendar.cpp">range-v3 implementation</a>.</p>
<p>See <a href="aln__filter_8cpp_source.html">aln_filter.cpp</a> for more advanced examples of use.</p>
<p>See <a href="https://ast-al.github.io/rangeless/docs/html/namespacerangeless_1_1fn.html">full documentation</a>.</p>
<h3>Features</h3>
<ul>
<li>Portable c++11. (examples are c++14)</li>
<li>Single-header.</li>
<li>Minimal standard library dependencies.</li>
<li>No inheritance, polymorphism, type-erasures, ADL, advanced metaprogramming, enable_ifs, concepts, preprocessor magic, arcane programming techniques (for some definition of arcane), or compiler-specific workarounds.</li>
<li>Low <code>#include</code> and compile-time overhead.</li>
<li>Enables trivial parallelization (see <a href="https://ast-al.github.io/rangeless/docs/html/group__parallel.html"><code>fn::to_async and fn::transform_in_parallel</code></a>).</li>
<li>Allows for trivial extension of functionality (see <a href="https://ast-al.github.io/rangeless/docs/html/group__transform.html"><code>fn::adapt</code></a>).</li>
</ul>
<h3>Minimum supported compilers: MSVC-19.15, GCC-4.9.3, clang-3.7, ICC-18</h3>
<p>This is not a range library, like <code>range-v3</code>, as it is centered around value-semantics rather than reference-semantics. This library does not know or deal with the multitude of range concepts; rather, it deals with data transformations via higher-order functions. It differentiates between two types of inputs: a <code>Container</code> and a lazy <code>seq&lt;NullaryInvokable&gt;</code> satisfying single-pass forward-only <code>InputRange</code> semantics (also known as a data-stream). Most of the function-objects in this library have two overloads of <code>operator()</code> respectively. Rather than composing views over ranges as with <code>range-v3</code>, <code>operator()</code>s take inputs by value, operate on it eagerly or compose a lazy <code>seq</code>, as appropriate (following the Principle of Least Astonishment), and return the result by value (with move-semantics) to the next stage.</p>
<p>E.g.</p><ul>
<li><code>fn::where</code><ul>
<li>given a container, passed by rvalue, returns the same container filtered to elements satisfying the predicate.</li>
<li>given a container, passed by lvalue-reference, returns a copy of the container with elements satisfying the predicate.</li>
<li>given a <code>seq</code>, passed by value, composes and returns a <code>seq</code> that will skip the elements not satisfying the predicate.</li>
</ul>
</li>
<li><code>fn::sort</code><ul>
<li>given a container, passed by value, returns the sorted container.</li>
<li>given a <code>seq</code>, passed by value, moves elements into a <code>std::vector</code>, and delegates to the above.</li>
</ul>
</li>
<li><code>fn::transform</code><ul>
<li>given a <code>seq</code>, passed by value, returns a <code>seq</code> wrapping a composition of the transform-function over the underlying <code>NullaryInvokable</code>.</li>
<li>given a container, passed by value, wraps it as <code>seq</code> and delegates to the above.</li>
</ul>
</li>
</ul>
<p>Some functions in this library internally buffer elements, as appropriate, with single-pass streaming inputs, whereas <code>range-v3</code>, on the other hand, imposes multipass ForwardRange or stronger requirement on the inputs in situations that would otherwise require buffering. This makes this library conceptually more similar to UNIX pipelines than to c++ ranges.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operations  </th><th class="markdownTableHeadNone">Buffering behavior  </th><th class="markdownTableHeadNone">Laziness   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fn::group_adjacent_by</code>, <code>fn::in_groups_of</code>  </td><td class="markdownTableBodyNone">buffer elements of the incoming group  </td><td class="markdownTableBodyNone">lazy   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fn::unique_all_by</code>  </td><td class="markdownTableBodyNone">buffer unique keys of elements seen so far  </td><td class="markdownTableBodyNone">lazy   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fn::drop_last</code>, <code>fn::sliding_window</code>  </td><td class="markdownTableBodyNone">buffer a queue of last <code>n</code> elements  </td><td class="markdownTableBodyNone">lazy   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fn::transform_in_parallel</code>  </td><td class="markdownTableBodyNone">buffer a queue of <code>n</code> executing async-tasks  </td><td class="markdownTableBodyNone">lazy   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fn::group_all_by</code>, <code>fn::sort_by</code>, <code>fn::lazy_sort_by</code>, <code>fn::reverse</code>, <code>fn::to_vector</code>  </td><td class="markdownTableBodyNone">buffer all elements  </td><td class="markdownTableBodyNone">eager   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fn::take_last</code>  </td><td class="markdownTableBodyNone">buffer a queue of last <code>n</code> elements  </td><td class="markdownTableBodyNone">eager   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fn::where_max_by</code>, <code>fn::where_min_by</code>  </td><td class="markdownTableBodyNone">buffer maximal/minimal elements as seen so-far  </td><td class="markdownTableBodyNone">eager   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fn::take_top_n_by</code>  </td><td class="markdownTableBodyNone">buffer top <code>n</code> elements as seen so-far  </td><td class="markdownTableBodyNone">eager   </td></tr>
</table>
<h3>Signaling <code>end-of-sequence</code> from a generator-function</h3>
<p>More often than not a generator-function that yields a sequence of values will not be an infinite Fibonacci sequence, but rather some bounded sequence of objects, either from a file, a socket, a database query, etc, so we need to be able to signal end-of-sequence. One way to do it is to yield elements wrapped in <code>std::unique_ptr</code> or <code>std::optional</code>: </p><div class="fragment"><div class="line">  <a class="code" href="group__io.html#gab5624a94f8786cb370675a260eb51928">fn::seq</a>([]() -&gt; std::unique_ptr&lt;...&gt; { ... })</div><div class="line">% <a class="code" href="group__filtering.html#ga1b8fd02fe6abd5defa5f5a6839e5b614">fn::take_while</a>([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> bool(x); })</div><div class="line">% <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a>(fn::get::dereferenced{})</div><div class="line">% ...</div></div><!-- fragment --><p> If your value-type has an "empty" state interpretable as end-of-inputs, you can use the value-type directly without wrapping.</p>
<p>If you don't care about incurring an exception-handling overhead once per whole seq, there's a simpler way of doing it: just return <code>fn::end_seq()</code> from the generator function (e.g. see my_intersperse example). This throws end-of-sequence exception that is caught under the hood (python-style). If you are in <code>-fno-exceptions</code> land, then this method is not for you.</p>
<h3>Summary of different ways of passing inputs</h3>
<div class="fragment"><div class="line">      <a class="code" href="group__io.html#gab5624a94f8786cb370675a260eb51928">fn::seq</a>([]{ ... }) % ... <span class="comment">// as input-range from a nullary invokable</span></div><div class="line"></div><div class="line">          std::move(vec) % ... <span class="comment">// pass a container by-move</span></div><div class="line">                    vec  % ... <span class="comment">// pass by-copy</span></div><div class="line"></div><div class="line">           <a class="code" href="group__view.html#ga9243f1562b82e61f7554101d304a41de">fn::from</a>(vec) % ... <span class="comment">// as move-view yielding elements by-move (std::move will make copies iff vec is const)</span></div><div class="line">          <a class="code" href="group__view.html#ga2ca6028fafc3067870b76bc78684c0fc">fn::cfrom</a>(vec) % ... <span class="comment">// as above, except always take as const-reference / yield by copy</span></div><div class="line">           <a class="code" href="group__io.html#ga30da17b10bf0974dc17153792de3c3af">fn::refs</a>(vec) % ... <span class="comment">// as seq taking vec by reference and yielding reference-wrappers</span></div><div class="line"></div><div class="line"><a class="code" href="group__view.html#ga9243f1562b82e61f7554101d304a41de">fn::from</a>(it_beg, it_end) % ... <span class="comment">// as a move-view into range (std::move will make copies iff const_iterator)</span></div><div class="line">  <a class="code" href="group__view.html#ga9243f1562b82e61f7554101d304a41de">fn::from</a>(beg_end_pair) % ... <span class="comment">// as above, as std::pair of iterators</span></div></div><!-- fragment --><p> Note: <code>fn::from</code> can also be used to adapt an lvalue-reference to an <code>Iterable</code> that implements <code>begin()</code> and <code>end()</code> as free-functions rather than methods.</p>
<h3><code>#include</code> and compilation-time overhead</h3>
<p>Despite packing a lot of functionality, <code>#include &lt;<a class="el" href="fn_8hpp.html">fn.hpp</a>&gt;</code> adds only a tiny sliver (~0.03s) of compilation-time overhead in addition to the few common standard library include-s that it relies upon:</p>
<p>"In God we trust, all others bring data": </p><div class="fragment"><div class="line"><span class="comment">// tmp.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if defined(STD_INCLUDES)</span></div><div class="line"><span class="preprocessor">#    include &lt;stdexcept&gt;</span></div><div class="line"><span class="preprocessor">#    include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#    include &lt;functional&gt;</span></div><div class="line"><span class="preprocessor">#    include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#    include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#    include &lt;deque&gt;</span></div><div class="line"><span class="preprocessor">#    include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#    include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#elif defined(INCLUDE_FN)</span></div><div class="line"><span class="preprocessor">#    include &quot;<a class="code" href="fn_8hpp.html">fn.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#elif defined(INCLUDE_RANGE_ALL)</span></div><div class="line"><span class="preprocessor">#    include &lt;range/v3/all.hpp&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="aln__filter_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"># just std-includes used by fn.hpp</div><div class="line">&gt;&gt;time for i in {1..10}; do g++ -std=c++14 -DSTD_INCLUDES=1 -o tmp.o -c tmp.cpp; done</div><div class="line">real    0m3.682s</div><div class="line">user    0m3.106s</div><div class="line">sys     0m0.499s</div><div class="line"></div><div class="line"># fn.hpp</div><div class="line">&gt;&gt;time for i in {1..10}; do g++ -std=c++14 -DINCLUDE_FN=1 -o tmp.o -c tmp.cpp; done</div><div class="line">real    0m3.887s</div><div class="line">user    0m3.268s</div><div class="line">sys     0m0.546s</div><div class="line"></div><div class="line"># range/v3/all.hpp, for comparison</div><div class="line">&gt;&gt;time for i in {1..10}; do g++ -std=c++14 -DINCLUDE_RANGE_ALL=1 -I. -o tmp.o -c tmp.cpp; done</div><div class="line">real    0m22.687s</div><div class="line">user    0m20.412s</div><div class="line">sys     0m2.043s</div></div><!-- fragment --><p>There are not many compiler-torturing metaprogramming techniques used by the library, so the template-instantiation overhead is reasonable as well (see the Top-5 most frequent word example; leaving it as an excercise to the reader to compare with raw-STL-based implementation).</p>
<h3>Discussion</h3>
<p>There seems to be a lot of misunderstanding about the intended use-cases for this style of coding.</p>
<p>Many programmers after getting introduced to toy examples get an impression that the intended usage is "to express the intent" or "better syntax" or to "separate the concerns", etc.</p>
<p>Others look at the toy examples and point out that they could be straightforwardly written as normal imperative code, and I tend to agree with them: Never write a code like: </p><div class="fragment"><div class="line">  std::move(xs)</div><div class="line">% <a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">fn::where</a>(     [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> x % 2 == 0; })</div><div class="line">% <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a>( [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> x * x; }</div><div class="line">% <a class="code" href="group__folding.html#ga8568617f52b0e084f2c1303d71705b69">fn::for_each</a>(  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { std::cout &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; })</div></div><!-- fragment --><p>, if it can be written simply as </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : xs)</div><div class="line">    <span class="keywordflow">if</span>(x % 2 == 0)</div><div class="line">        std::cerr &lt;&lt; x*x &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div></div><!-- fragment --><p> If you are doing "functional style" for no good reason, you are doing it wrong - there's no value-added and you are paiyng compile-time, debugging-layers, and possibly run-time overhead.</p>
<p>There are some scenarios where functional-style is useful:</p>
<h4>Const-correctness.</h4>
<p>By this I mean: when an lvalue is in the process of being built, it should be considered write only; when it is is being used, it should be read-only (declared const and enforced by the compiler, unless the intent is to <code>std::move</code> it). e.g. a contrived example </p><div class="fragment"><div class="line">map&lt;std::string, size_t&gt; word_counts{};</div><div class="line"></div><div class="line"><span class="comment">// modify the map of word-counts...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// ... many of code-lines later, that may or may not have modified word_counts...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// access word_counts</span></div></div><!-- fragment --><p> If <code>word_counts</code> could be declared const, you could ignore all the code that may-or-may-not modify word_counts between declaration and usage, e.g.: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> word_counts = words % fn::fold_d([](map&lt;std::string, size_t&gt; m, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; word)</div><div class="line">{</div><div class="line">    ++m[word];</div><div class="line">    <span class="keywordflow">return</span> std::move(m);</div><div class="line">};</div></div><!-- fragment --><p>Another code-pattern for this is immediately-executed-lambda. </p><div class="fragment"><div class="line"><span class="keyword">const</span> X x = [&amp;]</div><div class="line">{</div><div class="line">    X x{}; <span class="comment">// this shadows the outside-x above, and it&#39;s GOOD, </span></div><div class="line">           <span class="comment">// as we don&#39;t want to accidently access it here.</span></div><div class="line"></div><div class="line">    <span class="comment">// build X...</span></div><div class="line">    <span class="keywordflow">return</span> x;</div><div class="line">}();</div></div><!-- fragment --><h4>Reduction of mutable state.</h4>
<p>Non-composeable API force the programmer to declare mutable state that really should be temporary. e.g. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> values = get_values(); <span class="comment">// has to be non-const, because will sort</span></div><div class="line"><a class="code" href="group__ordering.html#ga41164a4ddefc2905489197e6959d00a1">std::sort</a>(values.begin(), values.end());</div></div><!-- fragment --><p> whereas a composeable API does not necessitate a mutation of an lvalue: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> sorted_values = get_values() % <a class="code" href="group__ordering.html#ga41164a4ddefc2905489197e6959d00a1">fn::sort</a>();</div></div><!-- fragment --><h4>Erase-remove idiom.</h4>
<p>If you feel that the idiomatic way of filtering a container is an abomination that should have never seen the light of day, then you'll find this library useful for that alone.</p>
<h4>Transformations over infinite (arbitrarily large) streams (<code>InputRange</code>s)</h4>
<p>The most useful use-case is the scenarios for writing a functional pipeline over an infinite stream that you want to manipulate lazily, like a UNIX pipeline, e.g. the above-mentioned <a href="aln__filter_8cpp_source.html">aln_filter.cpp</a>.</p>
<h3>Downsides and Caveats.</h3>
<p>Compilation errors related to templates are completely gnarly. For this reason the library has many <code>static_asserts</code> to help you figure things out. If you encounter a compilation error that could benefit from adding a <code>static_assert</code>, please open an issue.</p>
<p>Sometimes it may be difficult to reason about the complexity space and time requirements of some operations. There are two ways to approach this: 1) Peek into documentation where I discuss space and time big-O for cases that are not obvious (e.g. how <code>lazy_sort_by</code> differs from regular <code>sort_by</code>, or how <code>unique_all_by</code> operates in single-pass for <code>seq</code>s). 2) Feel free to peek under the hood of the library. Most of the code is intermediate-level c++ that should be within the ability to grasp by someone familiar with STL and <code>&lt;algorithm&gt;</code>.</p>
<p>There's a possibility that a user may instantiate a <code>seq</code> and then forget to actually iterate over it, e.g. </p><div class="fragment"><div class="line">std::move(inputs) % <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a>(...); <span class="comment">// creates and immediately destroys a lazy-seq.</span></div><div class="line"></div><div class="line"><span class="comment">// whereas the user code probably intended:</span></div><div class="line">std::move(inputs) % <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a>(...) % <a class="code" href="group__folding.html#ga8568617f52b0e084f2c1303d71705b69">fn::for_each</a>(...);</div></div><!-- fragment --><h3>References:</h3>
<ul>
<li><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html">Haskell Data.List</a></li>
<li><a href="https://www.scala-lang.org/api/2.13.x/scala/collection/immutable/LazyList.html">Scala LazyList</a></li>
<li><a href="https://hexdocs.pm/elixir/Stream.html">Elixir Stream</a></li>
<li><a href="https://package.elm-lang.org/packages/elm/core/latest/List">Elm List</a></li>
<li><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">O'Caml List</a></li>
<li><a href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/collections.seq-module-%5bfsharp%5d">F# Collections.Seq</a></li>
<li><a href="https://dlang.org/phobos/std_range.html">D std.range</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Rust Iterator</a></li>
</ul>
<p>c++ -specific (in no particular order):</p><ul>
<li><a href="https://en.cppreference.com/w/cpp/experimental/ranges">c++20 std::ranges</a></li>
<li><a href="https://github.com/tcbrindle/NanoRange">tcbrindle/NanoRange</a></li>
<li><a href="https://github.com/ericniebler/range-v3">ericniebler/range-v3</a></li>
<li><a href="https://github.com/Dobiasd/FunctionalPlus">Dobiasd/FunctionalPlus</a></li>
<li><a href="https://github.com/jscheiny/Streams">jscheiny/Streams</a></li>
<li><a href="https://www.codeproject.com/Articles/512935/A-Lazy-Stream-Implementation-in-Cplusplus">A Lazy Stream Implementation in C++11</a></li>
<li><a href="https://github.com/ryanhaining/cppitertools">ryanhaining/CPPItertools</a></li>
<li><a href="https://github.com/soheilhy/fn">soheilhy/fn</a></li>
<li><a href="https://github.com/LoopPerfect/conduit">LoopPerfect/conduit</a></li>
<li><a href="https://github.com/k06a/boolinq">k06a/boolinq</a></li>
<li><a href="https://github.com/pfultz2/linq">pfultz2/linq</a></li>
<li><a href="https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/index.html">boost.range</a></li>
<li><a href="https://archive.codeplex.com/?p=cpplinq">cpplinq</a></li>
<li><a href="https://github.com/simonask/rx-ranges">simonask/rx-ranges</a></li>
<li><a href="https://github.com/ReactiveX/RxCpp">ReactiveX/RxCpp</a></li>
<li><a href="https://github.com/arximboldi/zug">arximboldi/zug</a></li>
</ul>
<p>Recommended blogs:</p><ul>
<li><a href="https://ericniebler.com">Eric Niebler</a></li>
<li><a href="https://www.fluentcpp.com">fluent c++</a></li>
<li><a href="https://akrzemi1.wordpress.com">Andrzej's C++ blog</a></li>
<li><a href="https://foonathan.net">foonathan::blog()</a></li>
<li><a href="https://quuxplusone.github.io/blog">quuxplusone</a></li>
<li><a href="https://bartoszmilewski.com">Bartosz Milewski</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
